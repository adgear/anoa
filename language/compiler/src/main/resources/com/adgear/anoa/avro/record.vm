##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##     http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#if ($schema.getNamespace())
package $schema.getNamespace();
#end
@SuppressWarnings("all")
#if ($schema.getDoc())
/** $schema.getDoc() */
#end
#if ($this.isDeprecated($schema))@Deprecated
#end
#foreach ($annotation in $this.javaAnnotations($schema))
@$annotation
#end
@org.apache.avro.specific.AvroGenerated
public class ${this.mangle($schema.getName())} extends org.apache.avro.specific.SpecificRecordBase implements ${this.anoaInterfaceFullName($schema)}<${this.mangle($schema.getName())}> {

  static public final long serialVersionUID = ${this.getVersion($schema)};
  static public final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse(${this.javaSplit($schema.toString())});
  static public org.apache.avro.Schema getClassSchema() { return SCHEMA$; }

  static private java.lang.ThreadLocal<org.apache.avro.specific.SpecificDatumReader<${this.mangle($schema.getName())}>> SPECIFIC_DATUM_READER = new java.lang.ThreadLocal<org.apache.avro.specific.SpecificDatumReader<${this.mangle($schema.getName())}>>() {
    @Override protected org.apache.avro.specific.SpecificDatumReader initialValue() {
      return new org.apache.avro.specific.SpecificDatumReader<${this.mangle($schema.getName())}>(${this.mangle($schema.getName())}.class);
    }
  };

  static private java.lang.ThreadLocal<org.apache.avro.io.BinaryDecoder> BINARY_DECODER = new java.lang.ThreadLocal<org.apache.avro.io.BinaryDecoder>() {
    @Override protected org.apache.avro.io.BinaryDecoder initialValue() {
      return org.apache.avro.io.DecoderFactory.get().binaryDecoder(new byte[0], null);
    }
  };

  static public ${this.mangle($schema.getName())} fromBytes(byte[] binaryEncoding) {
    final ${this.mangle($schema.getName())} instance;
    try {
      instance = SPECIFIC_DATUM_READER.get().read(null, org.apache.avro.io.DecoderFactory.get().binaryDecoder(binaryEncoding, BINARY_DECODER.get()));
    } catch (java.io.IOException e) {
      throw new java.io.UncheckedIOException(e);
    }
    instance.lock((byte[]) binaryEncoding.clone());
    return instance;
  }

  static private java.lang.ThreadLocal<org.apache.avro.specific.SpecificDatumWriter<${this.mangle($schema.getName())}>> SPECIFIC_DATUM_WRITER = new java.lang.ThreadLocal<org.apache.avro.specific.SpecificDatumWriter<${this.mangle($schema.getName())}>>() {
    @Override protected org.apache.avro.specific.SpecificDatumWriter initialValue() {
      return new org.apache.avro.specific.SpecificDatumWriter<${this.mangle($schema.getName())}>(${this.mangle($schema.getName())}.class);
    }
  };

  static private java.lang.ThreadLocal<java.io.ByteArrayOutputStream> BINARY_ENCODER_STREAM = new java.lang.ThreadLocal<java.io.ByteArrayOutputStream>() {
    @Override protected java.io.ByteArrayOutputStream initialValue() {
      return new java.io.ByteArrayOutputStream();
    }
  };

  static private java.lang.ThreadLocal<org.apache.avro.io.BinaryEncoder> BINARY_ENCODER = new java.lang.ThreadLocal<org.apache.avro.io.BinaryEncoder>() {
    @Override protected org.apache.avro.io.BinaryEncoder initialValue() {
      return org.apache.avro.io.EncoderFactory.get().binaryEncoder(BINARY_ENCODER_STREAM.get(), null);
    }
  };

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    if (!isLocked()) {
      lock();
    }
    out.defaultWriteObject();
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, java.lang.ClassNotFoundException {
    in.defaultReadObject();
    byte[] bytes = _binaryEncoding;
    _binaryEncoding = null;
    SPECIFIC_DATUM_READER.get().read(this, org.apache.avro.io.DecoderFactory.get().binaryDecoder(bytes, BINARY_DECODER.get()));
    _binaryEncoding = bytes;
  }

  private byte[] _binaryEncoding;

#foreach ($field in $schema.getFields())
#if ($field.doc())
  /** $field.doc() */
#end
#foreach ($annotation in $this.javaAnnotations($field))
  @$annotation
#end
  transient private ${this.avroType($field.schema())} ${this.mangle($field.name())};
#if ($this.isUnboxedJavaTypeNullable($field.schema()))  transient private ${this.viewType($field.schema())} ${this.mangle($field.name())}_view;#end
#end

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>.
   */
  public ${this.mangle($schema.getName())}() {}

  @Override
  public org.apache.avro.Schema getSchema() { return SCHEMA$; }

  // Used by DatumWriter.  Applications should not call.
  @Override
  public java.lang.Object get(int field$) {
    switch (field$) {
#set ($i = 0)
#foreach ($field in $schema.getFields())
    case $i: return ${this.mangle($field.name())};
#set ($i = $i + 1)
#end
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  // Used by DatumReader.  Applications should not call.
  @Override
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    if (isLocked()) {
      throw new org.apache.avro.AvroRuntimeException("This record has already been locked.");
    }
    switch (field$) {
#set ($i = 0)
#foreach ($field in $schema.getFields())
    case $i: ${this.mangle($field.name())} = (${this.avroType($field.schema())}) value$; break;
#set ($i = $i + 1)
#end
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  public boolean isLocked() {
    return _binaryEncoding != null;
  }

  private void lock() {
    java.io.ByteArrayOutputStream baos = BINARY_ENCODER_STREAM.get();
    org.apache.avro.io.BinaryEncoder enc = BINARY_ENCODER.get();
    baos.reset();
    try {
      SPECIFIC_DATUM_WRITER.get().write(this, enc);
      enc.flush();
    } catch (java.io.IOException e) {
      throw new java.io.UncheckedIOException(e);
    }
    lock(baos.toByteArray());
  }

  private void lock(byte[] binaryEncoding) {
    _binaryEncoding = binaryEncoding;
#foreach ($field in $schema.getFields())
#if ($this.isUnboxedJavaTypeNullable($field.schema()))
  ${this.mangle($field.name())}_view = ${this.getView($field)};
#end
#end
  }

  public byte[] toByteArray() {
    return (byte[]) get()._binaryEncoding.clone();
  }

  public java.nio.ByteBuffer toByteBuffer() {
    return java.nio.ByteBuffer.wrap(get()._binaryEncoding).asReadOnlyBuffer();
  }

  @Override
  public boolean isAvro() { return true; }

  @Override
  public ${this.mangle($schema.getName())} get() {
    if (!isLocked()) {
      lock();
    }
    return this;
  }

#foreach ($field in $schema.getFields())
  /**
   * Gets the value of the '${this.mangle($field.name())}' field.
#if ($field.doc())   * $field.doc()
#end
   */
  @Override
#if ($this.isDeprecated($field))  @Deprecated
#end
  public ${this.viewType($field.schema())} ${this.generateGetMethod($schema, $field)}() {
    return #if ($this.isUnboxedJavaTypeNullable($field.schema()))get().${this.mangle($field.name())}_view#else${this.mangle($field.name())}#end;
  }
#foreach ($alias in $field.aliases())
  @Deprecated
  public ${this.viewType($field.schema())} ${this.generateGetMethod($schema, ${this.getAliasField($field, $alias)})}() {
    return #if ($this.isUnboxedJavaTypeNullable($field.schema()))get().${this.mangle($field.name())}_view#else${this.mangle($field.name())}#end;
  }
#end

#end
  /** Creates a new ${this.mangle($schema.getName())} RecordBuilder */
  static public ${schema.getNamespace()}.${this.mangle($schema.getName())}.Builder newBuilder() {
    return new ${schema.getNamespace()}.${this.mangle($schema.getName())}.Builder();
  }

  /** Creates a new ${this.mangle($schema.getName())} RecordBuilder by copying an existing Builder */
  static public ${schema.getNamespace()}.${this.mangle($schema.getName())}.Builder newBuilder(${schema.getNamespace()}.${this.mangle($schema.getName())}.Builder other) {
    return new ${schema.getNamespace()}.${this.mangle($schema.getName())}.Builder(other);
  }

  /** Creates a new ${this.mangle($schema.getName())} RecordBuilder by copying an existing ${this.anoaInterfaceFullName($schema)} instance */
  static public ${schema.getNamespace()}.${this.mangle($schema.getName())}.Builder newBuilder(${schema.getNamespace()}.${this.mangle($schema.getName())} other) {
    return new ${schema.getNamespace()}.${this.mangle($schema.getName())}.Builder(other);
  }

  /**
   * RecordBuilder for ${this.mangle($schema.getName())} instances.
   */
  static public class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<${this.mangle($schema.getName())}> implements org.apache.avro.data.RecordBuilder<${this.mangle($schema.getName())}> {

#foreach ($field in $schema.getFields())
    private ${this.avroType($field.schema())} ${this.mangle($field.name())};
#end

    /** Creates a new Builder */
    private Builder() {
      super(${schema.getNamespace()}.${this.mangle($schema.getName())}.SCHEMA$);
    }

    /** Creates a Builder by copying an existing Builder */
    private Builder(${schema.getNamespace()}.${this.mangle($schema.getName())}.Builder other) {
      super(other);
#foreach ($field in $schema.getFields())
      if (isValidValue(fields()[$field.pos()], other.${this.mangle($field.name())})) {
        this.${this.mangle($field.name())} = data().deepCopy(fields()[$field.pos()].schema(), other.${this.mangle($field.name())});
        fieldSetFlags()[$field.pos()] = true;
      }
#end
    }

    /** Creates a Builder by copying an existing ${schema.getNamespace()}.${this.mangle($schema.getName())} instance */
    private Builder(${schema.getNamespace()}.${this.mangle($schema.getName())} other) {
      super(${schema.getNamespace()}.${this.mangle($schema.getName())}.SCHEMA$);
#foreach ($field in $schema.getFields())
      if (isValidValue(fields()[$field.pos()], other.${this.mangle($field.name())})) {
        this.${this.mangle($field.name())} = data().deepCopy(fields()[$field.pos()].schema(), other.${this.mangle($field.name())});
        fieldSetFlags()[$field.pos()] = true;
      }
#end
    }

#foreach ($field in $schema.getFields())
    /** Gets the value of the '${this.mangle($field.name())}' field */
#if ($this.isDeprecated($field))    @Deprecated
#end
    public ${this.avroType($field.schema())} ${this.generateGetMethod($schema, $field)}() {
      return ${this.mangle($field.name())};
    }
#foreach ($alias in $field.aliases())
    @Deprecated
    public ${this.avroType($field.schema())} ${this.generateGetMethod($schema, $this.getAliasField($field, $alias))}() {
      return ${this.generateGetMethod($schema, $field)}();
    }
#end

    /** Sets the value of the '${this.mangle($field.name())}' field */
#if ($this.isDeprecated($field))    @Deprecated
#end
    public ${schema.getNamespace()}.${this.mangle($schema.getName())}.Builder ${this.generateSetMethod($schema, $field)}(${this.avroType($field.schema())} value) {
      validate(fields()[$field.pos()], value);
      this.${this.mangle($field.name())} = value;
      fieldSetFlags()[$field.pos()] = true;
      return this;
    }
#foreach ($alias in $field.aliases())
    @Deprecated
    public ${schema.getNamespace()}.${this.mangle($schema.getName())}.Builder ${this.generateSetMethod($schema, $this.getAliasField($field, $alias))}(${this.avroType($field.schema())} value) {
      return ${this.generateSetMethod($schema, $field)}(value);
    }
#end

    /** Checks whether the '${this.mangle($field.name())}' field has been set */
#if ($this.isDeprecated($field))    @Deprecated
#end
    public boolean ${this.generateHasMethod($schema, $field)}() {
      return fieldSetFlags()[$field.pos()];
    }
#foreach ($alias in $field.aliases())
    @Deprecated
    public boolean ${this.generateHasMethod($schema, $this.getAliasField($field, $alias))}() {
      return ${this.generateHasMethod($schema, $field)}();
    }
#end

    /** Clears the value of the '${this.mangle($field.name())}' field */
#if ($this.isDeprecated($field))    @Deprecated
#end
    public ${schema.getNamespace()}.${this.mangle($schema.getName())}.Builder ${this.generateClearMethod($schema, $field)}() {
#if (${this.isUnboxedJavaTypeNullable($field.schema())})
      ${this.mangle($field.name())} = null;
#end
      fieldSetFlags()[$field.pos()] = false;
      return this;
    }
#foreach ($alias in $field.aliases())
    @Deprecated
    public ${schema.getNamespace()}.${this.mangle($schema.getName())}.Builder ${this.generateClearMethod($schema, $this.getAliasField($field, $alias))}() {
      return ${this.generateClearMethod($schema, $field)}();
    }
#end

#end
    @Override
    public ${this.mangle($schema.getName())} build() {
      final ${this.mangle($schema.getName())} record;
      try {
        record = new ${this.mangle($schema.getName())}(#if ($schema.isError())getValue(), getCause()#end);
#foreach ($field in $schema.getFields())
        record.${this.mangle($field.name())} = fieldSetFlags()[$field.pos()] ? this.${this.mangle($field.name())} : (${this.avroType($field.schema())}) defaultValue(fields()[$field.pos()]);
#end
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
      record.lock();
      return record;
    }
  }
}
