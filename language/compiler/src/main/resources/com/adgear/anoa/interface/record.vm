#if ($schema.getNamespace())
package $schema.getNamespace();
#end

#if ($schema.getDoc())
/** $schema.getDoc() */
#end
#if ($this.isDeprecated($schema))
@Deprecated
#end
#foreach ($annotation in $this.javaAnnotations($schema))
@$annotation
#end
public interface ${this.anoaInterfaceName($schema)}<T> extends java.util.function.Supplier<T>, java.io.Serializable {

  default boolean isAvro() { return false; }
  default boolean isProtobuf() { return false; }
  default boolean isThrift() { return false; }

  /** Returns underlying object. */
  T get();

#foreach ($field in ${this.fields($schema)})

#if ($field.doc())  /** $field.doc() */
#end
#if ($this.isDeprecated($field))  @Deprecated
#end
  ${this.exportType($field.schema())} ${this.generateGetMethod($schema, $field)}();
#foreach ($alias in $field.aliases())

  @Deprecated
  default public ${this.exportType($field.schema())} ${this.generateGetMethod($schema, ${this.aliasField($field, $alias)})}() { return ${this.generateGetMethod($schema, $field)}(); }
#end
#end
#if ($this.isWithProtobuf())

  static final public class Protobuf implements ${this.anoaInterfaceName($schema)}<${this.protobufClassName($schema)}> {

    private byte[] binaryEncoding;
    transient private ${this.protobufClassName($schema)} wrapped;
#foreach ($field in ${this.fields($schema)})
#if ($this.hasProtobufExportField($field))
    transient private ${this.exportType($field.schema())} export_${this.mangle($field.name())};
#end
#end

    private Protobuf(${this.protobufClassName($schema)} wrapped, byte[] binaryEncoding) {
      this.wrapped = wrapped;
      this.binaryEncoding = binaryEncoding;
    }

    /** Constructs a new Protobuf instance based on a message's binary encoding. Only use this if you know what you're doing. */
    public Protobuf(byte[] binaryEncoding) { this(null, binaryEncoding); }

    @Override
    public boolean isProtobuf() { return true; }

    @Override
    public ${this.protobufClassName($schema)} get() {
      if (wrapped == null) {
        try {
          wrapped = ${this.protobufClassName($schema)}.parseFrom(binaryEncoding);
        } catch (java.io.IOException e) {
          throw new java.io.UncheckedIOException(e);
        }
      }
      return wrapped;
    }
#foreach ($field in ${this.fields($schema)})

    @Override
#if ($this.isDeprecated($field))
    @Deprecated
#end
    public ${this.exportType($field.schema())} ${this.generateGetMethod($schema, $field)}() {
#if ($this.hasProtobufExportField($field))
      if (export_${this.mangle($field.name())} == null) {
        export_${this.mangle($field.name())} = ${this.cast($field)}${this.protobufExportValue($schema, $field)};
      }
      return export_${this.mangle($field.name())};
#else
      return ${this.protobufExportValue($schema, $field)};
#end
    }
#end

    @Override
    public boolean equals(Object other) {
      if (other == this) return true;
      if (other == null && !(other instanceof Protobuf)) return false;
      return get().equals(((${this.anoaInterfaceName($schema)}) other).get());
    }

    @Override
    public int hashCode() { return get().hashCode(); }

    @Override
    public String toString() { return get().toString(); }

    private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
      if (binaryEncoding == null) { binaryEncoding = wrapped.toByteArray(); }
      out.defaultWriteObject();
    }

    /** Creates a new wrapped Protobuf message based on an instance of ${this.anoaInterfaceName($schema)}. */
    static public ${this.anoaInterfaceName($schema)}<${this.protobufClassName($schema)}> from(${this.anoaInterfaceName($schema)}<?> instance) {
      return new Protobuf(
          ${this.protobufClassName($schema)}.newBuilder()
#set ($i = 0)
#foreach ($field in ${this.fields($schema)})
            ${this.protobufImportField($schema, $field)}
#set ($i = $i + 1)
#end
            .build(),
          null);
    }

    /** Wraps an existing Protobuf message. */
    static public ${this.anoaInterfaceName($schema)}<${this.protobufClassName($schema)}> from(${this.protobufClassName($schema)} wrapped) {
      assert wrapped != null;
      return new Protobuf(wrapped, null);
    }

    /** Decodes a Protobuf message. */
    static public ${this.anoaInterfaceName($schema)}<${this.protobufClassName($schema)}> from(byte[] binaryEncoding) throws java.io.IOException {
      return new Protobuf(${this.protobufClassName($schema)}.parseFrom(binaryEncoding), binaryEncoding);
    }

    /** Returns new Protobuf builder instance with default values. */
    static public ${this.protobufClassName($schema)}.Builder newProtobufBuilder() {
      return ${this.protobufClassName($schema)}.newBuilder();
    }

    /** Returns new Protobuf builder instance based on existing prototype. */
    static public ${this.protobufClassName($schema)}.Builder newProtobufBuilder(${this.protobufClassName($schema)} other) {
      return ${this.protobufClassName($schema)}.newBuilder(other);
    }

    /** Returns Protobuf class for this struct. */
    static public java.lang.Class<${this.protobufClassName($schema)}> getProtobufClass() {
      return ${this.protobufClassName($schema)}.class;
    }

    /** Returns Protobuf protocol class for this struct. */
    static public java.lang.Class<${this.protobufProtocolClassName()}> getProtobufProtocolClass() {
      return ${this.protobufProtocolClassName()}.class;
    }

    /** Returns Protobuf descriptor for this struct. */
    static public com.google.protobuf.Descriptors.Descriptor getProtobufDescriptor() {
      return ${this.protobufClassName($schema)}.getDescriptor();
    }

    /** Returns Protobuf protocol descriptor for this struct. */
    static public com.google.protobuf.Descriptors.FileDescriptor getProtobufProtocolDescriptor() {
      return ${this.protobufProtocolClassName()}.getDescriptor();
    }

    static public final long serialVersionUID = ${this.version($schema)};
  }
#end
#if ($this.isWithThrift())

  static final public class Thrift implements ${this.anoaInterfaceName($schema)}<${this.thriftClassName($schema)}> {

    private ${this.thriftClassName($schema)} wrapped;
#foreach ($field in ${this.fields($schema)})
#if ($this.hasThriftExportField($field))
    transient private ${this.exportType($field.schema())} export_${this.mangle($field.name())};
#end
#end

    /** Wraps an existing instance. Only use this if you know what you are doing. */
    public Thrift(${this.thriftClassName($schema)} wrapped) { this.wrapped = wrapped; }

    /** Create a new wrapper. */
    public Thrift() { this(new ${this.thriftClassName($schema)}()); }

    @Override
    public boolean isThrift() { return true; }

    @Override
    public ${this.thriftClassName($schema)} get() { return wrapped; }
#foreach ($field in ${this.fields($schema)})

    @Override
#if ($this.isDeprecated($field))
    @Deprecated
#end
    public ${this.exportType($field.schema())} ${this.generateGetMethod($schema, $field)}() {
#if ($this.hasThriftExportField($field))
      if (export_${this.mangle($field.name())} == null) {
        export_${this.mangle($field.name())} = ${this.cast($field)}${this.thriftExportValue($field)};
      }
      return export_${this.mangle($field.name())};
#else
      return ${this.thriftExportValue($field)};
#end
    }
#end

    @Override
    public boolean equals(Object other) {
      if (other == this) return true;
      if (other == null && !(other instanceof Thrift)) return false;
      return wrapped.equals(((Thrift) other).wrapped);
    }

    @Override
    public int hashCode() { return wrapped.hashCode(); }

    @Override
    public String toString() { return wrapped.toString(); }

    /** Creates a new wrapped Thrift struct based on an instance of ${this.anoaInterfaceName($schema)}. */
    static public ${this.anoaInterfaceName($schema)}<${this.thriftClassName($schema)}> from(${this.anoaInterfaceName($schema)}<?> instance) {
      ${this.thriftClassName($schema)} copy = new ${this.thriftClassName($schema)}();
#set ($i = 0)
#foreach ($field in ${this.fields($schema)})
      copy.setFieldValue(${this.thriftClassName($schema)}._Fields.values()[$i], ${this.thriftImportValue($schema, $field)});
#set ($i = $i + 1)
#end
      return new Thrift(copy);
    }

    /** Creates a new wrapped Thrift struct copied from an existing instance. */
    @SuppressWarnings("all")
    static public ${this.anoaInterfaceName($schema)}<${this.thriftClassName($schema)}> from(${this.thriftClassName($schema)} instance) {
      return new Thrift((${this.thriftClassName($schema)}) instance.deepCopy());
    }

    /** Returns Thrift class for this struct. */
    static public java.lang.Class<${this.thriftClassName($schema)}> getThriftClass() {
      return ${this.thriftClassName($schema)}.class;
    }

    /** Returns Thrift metadata map for this struct. */
    static public java.util.Map<${this.thriftClassName($schema)}._Fields, org.apache.thrift.meta_data.FieldMetaData> getThriftMetadataMap() {
      return ${this.thriftClassName($schema)}.metaDataMap;
    }

    static public final long serialVersionUID = ${this.version($schema)};
  }
#end
}
