/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Some portions of this file were modeled after the example Java 1.5
 * parser included with JavaCC. The following license applies to those
 * portions:
 *
 * Copyright (c) 2006, Sun Microsystems, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Sun Microsystems, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Notice:
 * This file is based off 'idl.jj' from the Apache Avro (TM) project.
 */

options {
  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = true;
  ERROR_REPORTING = true;
  STATIC = false;
  FORCE_LA_CHECK = true;
  JDK_VERSION = "1.6";
}

PARSER_BEGIN(AnoaParser)

package com.adgear.anoa.parser;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.net.URL;

import org.apache.avro.Schema;
import org.apache.avro.Schema.*;
import org.apache.avro.Protocol;
import org.apache.avro.Protocol.*;

import org.codehaus.jackson.JsonNode;
import org.codehaus.jackson.node.*;

import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;
import org.apache.commons.lang3.StringEscapeUtils;


/**
 * Grammar to parse the Anoa language into an Avro Protocol.
 *
 * Note: each instance is not thread-safe, but multiple separate instances are safely independent.
 */
public class AnoaParser implements Closeable {

  static final private ThreadLocal<String> DOC = new ThreadLocal<String>();

  static void setDoc(String doc) {
    DOC.set(doc.trim());
  }

  static String getDoc() {
    String doc = DOC.get();
    DOC.set(null);
    return doc;
  }

  static private URL toURL(String namespace, File baseDir, ClassLoader resourceLoader)
      throws IOException {
    String path = namespace.replace('.', File.separatorChar) + ".anoa";
    File completeFile = (baseDir == null) ? new File(path) : new File(baseDir, path);
    if (completeFile.exists()) {
      return completeFile.toURL();
    } else if (resourceLoader != null) {
      URL url = resourceLoader.getResource(path);
      if (url != null) {
        return url;
      }
    }
    throw new FileNotFoundException(path);
  }

  String namespace;
  File baseDir;
  ClassLoader resourceLoader;
  Map<Schema,Boolean> types = new LinkedHashMap<Schema,Boolean>();
  List<String> enumSymbols = new ArrayList<String>();
  List<String> imports = new ArrayList<String>();

  private AnoaParser(String namespace, File baseDir, ClassLoader resourceLoader, URL input)
      throws IOException {
    this(input.openStream(), "UTF-8");
    this.namespace = namespace;
    this.baseDir = baseDir;
    this.resourceLoader = resourceLoader;
  }

  public AnoaParser(String namespace, File baseDir) throws IOException {
    this(namespace, baseDir, null, toURL(namespace, baseDir, null));
  }

  public AnoaParser(String namespace, ClassLoader resourceLoader) throws IOException {
    this(namespace, null, resourceLoader, toURL(namespace, null, resourceLoader));
  }

  @Override
  public void close() throws IOException {
    jj_input_stream.inputStream.close();
  }

  Protocol exportProtocol() {
    String name = getFullName(namespace);
    name = name.substring(name.lastIndexOf('.') + 1);
    Protocol p = new Protocol(name, namespace);
    List<Schema> exportedTypes = new ArrayList<Schema>();
    for (Map.Entry<Schema,Boolean> entry : types.entrySet()) {
      if (Boolean.FALSE.equals(entry.getValue())) {
        exportedTypes.add(entry.getKey());
      }
    }
    p.setTypes(exportedTypes);
    return p;
  }

  Schema findTypeByFullName(String name) {
    for (Schema schema : types.keySet()) {
      if (name.equals(schema.getFullName()) || schema.getAliases().contains(name)) {
        return schema;
      }
    }
    return null;
  }

  String getFullName(String name) {
    int index = name.lastIndexOf('.');
    return getFullName(name.substring(index + 1), name.substring(0, index));
  }

  String getFullName(String name, String namespace) {
    StringBuilder sb = new StringBuilder();
    sb.append((namespace == null) ? this.namespace : namespace).append('.');
    boolean capitalize = true;
    for (char c : name.toCharArray()) {
      if (c == '_') {
        capitalize = true;
      } else if (capitalize) {
        capitalize = false;
        sb.append(Character.toUpperCase(c));
      } else {
        sb.append(c);
      }
    }
    return sb.toString();
  }

  void importProtocol(String namespace) throws IOException, ParseException {
    if (!imports.contains(namespace)) {
      URL url = toURL(namespace, this.baseDir, this.resourceLoader);
      AnoaParser anoaParser = new AnoaParser(namespace, this.baseDir, this.resourceLoader, url);
      Protocol importedProtocol = anoaParser.CompilationUnit();
      for (Schema importedType : importedProtocol.getTypes()) {
        types.put(importedType, true);
      }
      imports.add(namespace);
    }
  }

  protected ParseException error(String message, Token token) {
    String msg = message + ", line " + token.beginLine + ", column " + token.beginColumn;
    return new ParseException(msg);
  }
}

PARSER_END(AnoaParser)

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

SKIP :
{
  <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")?>
}

SKIP :
{
  <"/**" ~["/"]> { input_stream.backup(1); } : DOC_COMMENT
|
  "/*" : MULTI_LINE_COMMENT
}

<DOC_COMMENT,MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

<DOC_COMMENT>
SPECIAL_TOKEN :
{
  <"*/" > { AnoaParser.setDoc(image.substring(0, image.length() - 2)); } : DEFAULT
}

<MULTI_LINE_COMMENT>
SKIP :
{
  <"*/" > : DEFAULT
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < BOOLEAN: "boolean" >
|
  < BYTES: "bytes" >
|
  < DEPRECATED: "deprecated" >
|
  < DOUBLE: "double" >
|
  < FALSE: "false" >
|
  < FLOAT: "float" >
|
  < INT: "int" >
|
  < LIST: "list" >
|
  < LONG: "long" >
|
  < MAP: "map" >
|
  < REMOVED: "removed" >
|
  < STRING: "string" >
|
  < TRUE: "true" >
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
    ("-")?
    ( <DECIMAL_LITERAL> (["l","L"])?
    | <HEX_LITERAL>     (["l","L"])?
    | <OCTAL_LITERAL>   (["l","L"])?
    )
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
  ("-")?
    ( "NaN" | "Infinity" |
      <DECIMAL_FLOATING_POINT_LITERAL> | <HEXADECIMAL_FLOATING_POINT_LITERAL> )
  >
|
  < #DECIMAL_FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <DECIMAL_EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<DECIMAL_EXPONENT>)? ["f","F","d","D"]
  >
|
  < #DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < #HEXADECIMAL_FLOATING_POINT_LITERAL:
        "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])+ (".")? <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
      | "0" ["x", "X"] (["0"-"9","a"-"f","A"-"F"])* "." (["0"-"9","a"-"f","A"-"F"])+ <HEXADECIMAL_EXPONENT> (["f","F","d","D"])?
  >
|
  < #HEXADECIMAL_EXPONENT: ["p","P"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
|
  < HEXADECIMAL_STRING_LITERAL: (["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"])* >
}

/* IDENTIFIERS */

TOKEN :
{
  < ENUM_SYMBOL: ["A"-"Z"] ( "_" ["A"-"Z"] | ["A"-"Z","0"-"9"] )* >
|
  < IDENTIFIER: ["a"-"z"] ( "_" ["a"-"z"] | ["a"-"z","0"-"9"] )* >
|
  < QUALIFIED_IDENTIFIER: ["a"-"z"] ( [".","_"] ["a"-"z"] | ["a"-"z","0"-"9"] )* >
}

/* SEPARATORS */

TOKEN :
{
  < LBRACE: "{" >
|
  < RBRACE: "}" >
|
  < LBRACK: "[" >
|
  < RBRACK: "]" >
|
  < SEMICOLON: ";" >
|
  < COMMA: "," >
|
  < PIPE: "|" >
|
  < DOT: "." >
}

TOKEN :
{
  < LT: "<" >
|
  < GT: ">" >
|
  < TICK: "`" >
}


/*********************************************
 * THE ANOA LANGUAGE GRAMMAR STARTS HERE *
 *********************************************/

/**
 * The input to AnoaParser is a CompilationUnit, which is currently just a single Avro Protocol.
 */
Protocol CompilationUnit():
{ }
{
  ( TypeDeclaration() ) *
  ( < "\u001a" > )?
  ( <STUFF_TO_IGNORE: ~[]> )?
  <EOF>
  { return this.exportProtocol(); }
}

void TypeDeclaration():
{
  Token t;
  String typeName;
  String doc = getDoc();
  List<String> aliases = new ArrayList<String>();
  List<String> enumSymbols = new ArrayList<String>();
  List<Field> structFields = new ArrayList<Field>();
  Schema type;
}
{
  typeName = TypeName()
  ( TypeAlias(typeName, aliases) ) *
  (
    <LBRACK> ( EnumSymbol(enumSymbols) ( <COMMA> | <SEMICOLON> ) ? ) + <RBRACK>
    { type = Schema.createEnum(typeName, doc, this.namespace, enumSymbols); }
  |
    <LBRACE> ( FieldDeclaration(structFields) ) + <RBRACE>
    {
      type = Schema.createRecord(typeName, doc, this.namespace, false);
      type.setFields(structFields);
    }
  )
  {
    for (String alias : aliases) {
      int index = alias.lastIndexOf('.');
      type.addAlias(alias.substring(index + 1), alias.substring(0, index));
    }
    this.types.put(type, false);
  }
}

String TypeName() :
{ Token t;}
{
  t = Identifier()
  {
    String name = this.getFullName(t.image, null);
    if (null != this.findTypeByFullName(name)) {
      throw this.error("Type name collision", t);
    }
    return name;
  }
}

Token Identifier() :
{ Token t; }
{
  ( t = <IDENTIFIER> | <TICK> t = AnyIdentifier() <TICK> )
  { return t; }
}

Token AnyIdentifier() :
{ Token t; }
{
  ( t = <BOOLEAN>
  | t = <BYTES>
  | t = <DOUBLE>
  | t = <FALSE>
  | t = <FLOAT>
  | t = <INT>
  | t = <LIST>
  | t = <LONG>
  | t = <MAP>
  | t = <STRING>
  | t = <TRUE>
  | t = <IDENTIFIER> )
  { return t; }
}

void TypeAlias(String typeName, List<String> aliases) :
{
  Token t;
  String name;
}
{
  (
    t = Identifier()
    { name = this.getFullName(t.image, null); }
  |
    t = <QUALIFIED_IDENTIFIER>
    { name = this.getFullName(t.image); }
  )
  {
    if (typeName.equals(name)) {
      throw this.error("Type alias is identical to type name", t);
    }
    if (aliases.contains(name)) {
      throw this.error("Repeated type alias", t);
    }
    if (null != this.findTypeByFullName(name)) {
      throw this.error("Type alias name collision", t);
    }
    aliases.add(name);
  }
}

void EnumSymbol(List<String> enumSymbols) :
{ Token t; }
{
  t = <ENUM_SYMBOL>
  {
    String symbol = t.image;
    if (enumSymbols.contains(symbol)) {
      throw this.error("Repeated enum symbol", t);
    }
    if (this.enumSymbols.contains(symbol)) {
      throw this.error("Enum symbol name collision", t);
    }
    this.enumSymbols.add(symbol);
    enumSymbols.add(symbol);
  }
}

void FieldDeclaration(List<Field> fields) :
{
  Schema type;
  JsonNode defaultValue = null;
}
{
  (
    <BOOLEAN> defaultValue = BooleanDefault() { type = Schema.create(Type.BOOLEAN); }
  |
    <BYTES>   defaultValue = BytesDefault()   { type = Schema.create(Type.BYTES);   }
  |
    <DOUBLE>  defaultValue = DecimalDefault() { type = Schema.create(Type.DOUBLE);  }
  |
    <FLOAT>   defaultValue = DecimalDefault() { type = Schema.create(Type.FLOAT);   }
  |
    <INT>     defaultValue = IntegerDefault() { type = Schema.create(Type.INT);     }
  |
    <LONG>    defaultValue = IntegerDefault() { type = Schema.create(Type.LONG);    }
  |
    <STRING>  defaultValue = StringDefault()  { type = Schema.create(Type.STRING);  }
  |
    <LIST> <LT> type = WrappedType() <GT>
    {
      type = Schema.createArray(type);
      defaultValue = JsonNodeFactory.instance.arrayNode();
    }
  |
    <MAP> <LT> <STRING> <COMMA> type = WrappedType() <GT>
    {
      type = Schema.createMap(type);
      defaultValue = JsonNodeFactory.instance.objectNode();
    }
  |
    type = ReferenceType()
    {
      if (type.getType() == Type.RECORD) {
        List<Schema> unionTypes = new ArrayList();
        unionTypes.add(Schema.create(Schema.Type.NULL));
        unionTypes.add(type);
        type = Schema.createUnion(unionTypes);
        defaultValue = NullNode.getInstance();
      } else {
        defaultValue = TextNode.valueOf(type.getEnumSymbols().get(0));
      }
    }
  )
  FieldNameDeclaration(fields, type, defaultValue)
}

JsonNode BooleanDefault() :
{ BooleanNode n = BooleanNode.FALSE; }
{
  ( <PIPE> ( <FALSE> | ( <TRUE> { n = BooleanNode.TRUE; } ) ) ) ?
  { return n; }
}

JsonNode BytesDefault() :
{ Token t = null; }
{
  ( <PIPE> t = <HEXADECIMAL_STRING_LITERAL> ) ?
  {
    if (t == null) {
      return TextNode.valueOf("");
    } else {
      try {
        return TextNode.valueOf(new String(Hex.decodeHex(t.image.toCharArray())));
      } catch (DecoderException e) {
        throw this.error("Failed to decode hex string: " + e, t);
      }
    }
  }
}

JsonNode DecimalDefault() :
{ Token t = null; }
{
  ( <PIPE> t = <FLOATING_POINT_LITERAL> ) ?
  { return DoubleNode.valueOf((t == null) ? 0.0 : Double.parseDouble(t.image)); }
}

JsonNode IntegerDefault() :
{ Token t = null; }
{
  ( <PIPE> t = <INTEGER_LITERAL> ) ?
  { return LongNode.valueOf((t == null) ? 0L : Long.parseLong(t.image)); }
}

JsonNode StringDefault() :
{ Token t = null; }
{
  ( <PIPE> t = <STRING_LITERAL> ) ?
  {
    String betweenQuotes = (t == null) ? "" : t.image.substring(1, t.image.length() - 1);
    return TextNode.valueOf(StringEscapeUtils.unescapeJson(betweenQuotes));
  }
}


Schema WrappedType() :
{ Schema type; }
{
  (
    <BOOLEAN> { type = Schema.create(Type.BOOLEAN); }
  |
    <BYTES>   { type = Schema.create(Type.BYTES);   }
  |
    <DOUBLE>  { type = Schema.create(Type.DOUBLE);  }
  |
    <FLOAT>   { type = Schema.create(Type.FLOAT);   }
  |
    <INT>     { type = Schema.create(Type.INT);     }
  |
    <LONG>    { type = Schema.create(Type.LONG);    }
  |
    <STRING>  { type = Schema.create(Type.STRING);  }
  |
    type = ReferenceType()
  )
  { return type;}
}

Schema ReferenceType() :
{
  Token t;
  String name;
}
{
  (
    t = Identifier()
    { name = this.getFullName(t.image, null); }
  |
    t = <QUALIFIED_IDENTIFIER>
    { name = this.getFullName(t.image); }
  )
  {
    Schema type = this.findTypeByFullName(name);
    if (null == type) {
      String namespace = name.substring(0, name.lastIndexOf('.'));
      try {
        this.importProtocol(namespace);
      } catch (FileNotFoundException e) {
        throw this.error("Unknown namespace '" + namespace + "': " + e, t);
      } catch (IOException e) {
        throw this.error("Error importing namespace: " + e, t);
      }
      type = this.findTypeByFullName(name);
      if (null == type) {
        throw this.error("Referenced type not found in imported namespace", t);
      }
    }
    return type;
  }
}

void FieldNameDeclaration(List<Field> structFields, Schema type, JsonNode defaultValue) :
{
  Token propKey = null;
  String name;
}
{
  ( propKey = <DEPRECATED> | propKey = <REMOVED> ) ?
  name = FieldName(structFields)
  {
    Field field = new Field(name, type, getDoc(), defaultValue);
    if (propKey != null) {
      field.addProp(propKey.image, BooleanNode.TRUE);
    }
  }
  (
    name = FieldName(structFields)
    { field.addAlias(name); }
  ) *
  <SEMICOLON>
  { structFields.add(field); }
}

String FieldName(List<Field> structFields) :
{ Token t; }
{
  t = Identifier()
  {
    String fieldName = t.image;
    for (Field field : structFields) {
      if (fieldName.equals(field.name())) {
        throw this.error("Field name collision", t);
      }
    }
    return fieldName;
  }
}
